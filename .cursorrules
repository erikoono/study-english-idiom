# 個人開発用 Cursor Rules
# これらのルールは個人開発プロジェクトでの品質とベストプラクティスを確保するためのものです

## 基本原則
- 常に可読性を重視し、自己説明的なコードを書く
- SOLID原則に従った設計を心がける
- DRY（Don't Repeat Yourself）原則を守る
- YAGNI（You Aren't Gonna Need It）原則を適用し、必要以上の機能は追加しない
- シンプルで保守しやすいソリューションを優先する

## コーディングスタイル
- 一貫したインデント（スペース2個またはタブ）を使用
- 適切な命名規則を使用（camelCase、snake_case、PascalCaseを言語に応じて）
- 行の長さは80-120文字以内に制限
- 不要な空行や複雑なネストを避ける
- セミコロンの使用は言語の慣習に従う

## 言語固有設定

### JavaScript/TypeScript
- TypeScriptを優先使用し、strict modeを有効にする
- ESLintとPrettierによる自動フォーマットを活用
- constを優先し、letは必要な場合のみ使用
- 型安全性を重視し、anyの使用は最小限に
- 非同期処理にはasync/awaitを優先
- モダンなJavaScript機能（ES6+）を積極的に活用

### Python
- PEP8に準拠したコーディングスタイル
- type hintsを積極的に使用
- f-stringsを文字列フォーマットに使用
- リスト内包表記やジェネレータを適切に活用
- doctringによる適切なドキュメント化

### Go
- gofmtによる標準フォーマット
- 短く明確な変数名を使用
- エラーハンドリングを適切に実装
- interfaceの活用でテスタブルなコードを作成

### PHP/Laravel
- PSR-12コーディング標準に準拠
- Eloquent ORMを活用したデータベース操作
- Artisanコマンドを使ったコード生成とメンテナンス
- ミドルウェアによる横断的関心事の実装
- サービスコンテナと依存性注入の活用
- Bladeテンプレートエンジンの適切な使用
- バリデーションルールの明確な定義
- リソースクラスによるAPIレスポンスの統一
- Job/Queueによる非同期処理の実装
- Event/Listenerによるイベント駆動設計

## コメントとドキュメント
- コードの「なぜ」を説明するコメントを重視
- 「何を」しているかは自明なコードで表現
- 複雑なアルゴリズムには詳細な説明を追加
- TODOコメントには期限や担当者を明記
- APIにはJSDoc、docstring等の適切なドキュメントを作成

## エラーハンドリング
- 早期リターン（early return）パターンを活用
- カスタム例外・エラー型を適切に定義
- ログレベルを適切に設定（DEBUG、INFO、WARN、ERROR）
- ユーザーフレンドリーなエラーメッセージを提供
- パニック・クラッシュを避け、graceful degradationを実装

## テスト
- テスト駆動開発（TDD）を可能な限り採用
- 単体テスト、統合テスト、E2Eテストの適切な組み合わせ
- テストケースには明確な命名を使用
- Given-When-Thenパターンでテストを構造化
- モックとスタブを適切に活用
- テストカバレッジは80%以上を目標

## セキュリティ
- 入力値の検証とサニタイゼーションを徹底
- SQLインジェクション、XSSなどの一般的な脆弱性を防止
- 認証・認可の実装は標準ライブラリを使用
- シークレット情報は環境変数で管理
- HTTPSとセキュアヘッダーの使用を強制
- 依存関係の脆弱性を定期的にチェック

## パフォーマンス
- プレマチュア最適化を避け、測定に基づく最適化を実施
- データベースクエリの最適化（N+1問題の回避など）
- キャッシュ戦略の適切な実装
- 非同期処理とパラレル処理の活用
- メモリリークの防止
- 適切なアルゴリズムとデータ構造の選択

## アーキテクチャ
- 関心の分離を重視した設計
- 依存性の注入パターンを活用
- レイヤードアーキテクチャまたはヘキサゴナルアーキテクチャを採用
- APIファーストの設計アプローチ
- マイクロサービスよりもモノリシックファーストを検討

## Git & バージョン管理

### ブランチ戦略
- **main ブランチへの直接プッシュは禁止**
- 全ての変更は feature ブランチから Pull Request 経由で行う
- main ブランチは常にデプロイ可能状態を維持
- ブランチ命名規則: `feature/機能名`、`fix/修正内容`、`docs/ドキュメント更新内容`

### コミットメッセージ
**Conventional Commits** 形式を厳密に適用：
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

#### Type（必須）
- `feat`: 新機能の追加
- `fix`: バグ修正
- `docs`: ドキュメントの変更
- `style`: フォーマット、セミコロン追加など（機能に影響しない変更）
- `refactor`: リファクタリング（機能追加でもバグ修正でもない変更）
- `perf`: パフォーマンス改善
- `test`: テストの追加や修正
- `chore`: ビルドプロセス、補助ツール、ライブラリの変更

#### 例
```
feat(auth): ユーザー認証機能を追加

Google OAuth 2.0を使用したログイン機能を実装
- OAuth認証フローの実装
- ユーザー情報の取得と保存
- セッション管理の追加

Closes #123
```

### Pull Request
- **PR作成は必須**: すべての変更はPR経由で行う
- **詳細なPR概要**: 以下の項目を含める
  ```markdown
  ## 概要
  この変更の目的と背景を説明

  ## 変更内容
  - 変更点1
  - 変更点2
  - 変更点3

  ## テスト
  - [ ] 単体テストを追加/更新
  - [ ] 手動テストを実施
  - [ ] 既存機能への影響確認

  ## 関連Issue
  Closes #[issue番号]

  ## スクリーンショット（UI変更の場合）
  変更前/変更後の画像

  ## レビューポイント
  特に注意してレビューしてほしい箇所
  ```

### コミット粒度
- **論理的な単位**でコミットを分割
- 1つのコミットは1つの責務のみ
- 「とりあえず」や「WIP」コミットは避ける
- コミット前に `git diff` で変更内容を確認

### バージョン管理
- セマンティックバージョニング（major.minor.patch）を採用
- タグを使用してリリースポイントを明示
- リリースノートで変更内容を明確に記載

## 依存関係管理
- 依存関係は最小限に抑える
- ライセンス互換性を確認
- 定期的な依存関係の更新
- lock fileを必ずバージョン管理に含める

## CI/CD
- 自動テスト、リント、フォーマットチェックを実装
- デプロイパイプラインの自動化
- ブルーグリーンデプロイメントまたはカナリアデプロイを採用
- ロールバック戦略を事前に準備

## 開発ツール
- IDEの設定ファイルをプロジェクトに含める
- デバッガーの活用を推奨
- プロファイリングツールでボトルネックを特定
- 静的解析ツールを活用

## 設定管理
- 環境固有の設定は環境変数で管理
- 設定ファイルはYAMLまたはJSONで構造化
- 機密情報は絶対にコードに含めない
- 設定の検証機能を実装

## ログとモニタリング
- 構造化ログ（JSON形式）を使用
- 適切なログレベルとコンテキスト情報を含める
- メトリクスとアラートを設定
- 分散トレーシングを実装（必要に応じて）

## ドキュメント
- README.mdにプロジェクトの概要、セットアップ、使用方法を記載
- ADR（Architecture Decision Records）で重要な設計決定を記録
- API仕様書を自動生成・更新

## その他
- 国際化（i18n）を考慮した実装
- アクセシビリティを重視したUI設計
- レスポンシブデザインの実装
- SEO対策の基本事項を実装

## AI開発支援活用
- コード生成時は必ずレビューと理解を行う
- AI提案のコードにはテストを追加
- セキュリティリスクを人間が最終確認
- 生成されたコードの可読性を人間が評価
- 複雑なロジックは段階的に構築・検証 